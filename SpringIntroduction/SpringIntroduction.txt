static 폴더
html을 화면 상에 나타나게끔 한다.
웹 브라우저 -> 내장 톰켓 서버가 요청을 받음 -> 스프링 컨테이너가 컨트롤러에서 html파일을 찾음 -> resource파일의 html파일을 찾음 -> 반환 

MVC(Model, View, Controller) 와 템플릿 엔진
템플릿 엔진 : htlm을 변환시켜 화면에 나타냄


@ResponseBody :

1. Controller가 메소드 찾음.
Annotation을 확인하고 HTTP Body에 문자 내용을 직접 반환하겠다고 함.

2. HttpMessageConverter(JsonConverter, StringConverter)가 작동한다.

문자인 경우(StringHttpMessageConverter)
그냥 넘김.

객체인 경우(MappingJackson2HttpMessageConverter)
json방식으로 데이터를 형성하여 http응답에 반환하겠다.


일반적인 웹 애플리케이션 계층 구조
컨트롤러 : 웹 mvc의 컨트롤러
서비스 : 핵심 로직 구현, 예) 중복 회원가입 불가 등.
리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
도메인 : 도메인 객체, 예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리됨.


테스트케이스 : 개발한 기능을 실행해서 정상 작동하는지 검증. Junit 이라는 프레임워크로 테스트 실행하여 사용.
테스트는 실행 순서 상관없이 실행된다.
테스트는 끝날 때마다 데이터를 지워주어야한다. (@AfterEach 사용)
테스트 메소드는 한글로 이름 만들어도 된다.

테스트주도개발(TDD, Test-Driven-Development) : 테스트케이스를 먼저 만들고 개발. 틀을 만들고 개발한다 보면 된다.

테스트 수가 많으면 build혹은 gradlew test 하면 된다.

규칙) 서비스는 비지니스 의존적으로 설계, 리포지토리는 기계적 용어 선택.

<단축키>
게터와 세터 : Alt + insert
중복이름 변경 : shift + f6
Ctrl + shift + t를 이용하여 클래스 테스트 케이스  쉽게 만들기.
변수 추출하기 : Ctrl + Alt + V, 알아서 반환해줌.
리팩토링 : Ctrl + Alt + Shift + T
이전 실행 다시 실행 : shift + f10
최근 목록 : Ctrl + E

DI(Dependency Injection)란 @Autowired 개념을 알기 위해 먼저 DI 개념을 알아야 합니다. 
DI(의존성 종속, Dependency Injection)란, 클래스간의 의존관계를 스프링 컨테이너가 자동으로 연결해주는 것을 말합니다. 
* Dependency 란, 객체가 다른 객체와 상호작용하는 것을 말합니다. 
클래스 A가 클래스 B,C와 상호작용한다면 객체 A는 객체B,C와 의존관계입니다. 
코드에서 직접적인 연관관계가 발생하지 않아 각 클래스들의 변경이 자유로워 집니다. 이를 '느슨한 관계'라고 합니다.
각 클래스들간 결합도가 높게되면 나중에 프로젝트가 복잡해질 시 유지보수가 힘들어진다. 따라서 각 클래스간 연관 관계를 클래스 자체 내에서 맺어주는 것이 아니라 스프링 자체에서 설정을 통해 연관 관계를 맺어줌으로써 결합도를 낮춘다.
클래스의 변경 사항이 연속적으로 다른 클래스에 영향(자바코드에서 직접 객체를 생성하여 사용하는 것)을 미친다면 좋은 방법은 아닙니다.

https://kingofbackend.tistory.com/41

스프링 빈이란?
Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라고 부른다.

IoC(Inversion of Control) 특징 : 일반적으로 처음 자바를 배울 때 각 객체들이 프로그램의 흐름을 결정하고 각 객체를 직접 생성하고 조작하는 작업을 했다.
예를 들어 B객체를 A객체 내에서 생성하고 메소드 호출하는 방식.
하지만 IoC가 적용되면서, 객체의 생성을 특별한 관리 위임 주체에게 맡긴다. 따라서 사용자가 직접 객체를 생성하지않고, 객체의 생명주기를 컨트롤하는 주체는 다른 주체가 된다.
즉, 사용자의 제어권을 다른 주체에게 넘기는 방식이다. 

https://biggwang.github.io/2019/08/31/Spring/IoC,%20DI%EB%9E%80%20%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/

직접 new를 이용하여 생성한 객체가 아니라, Spring에 의하여 관리당하는 자바 객체를 사용합니다. 이렇게 Spring에 의하여 생성되고 관리되는 자바 객체를 Bean이라고 한다.
빈을 등록하기 위해서는 @Component 어노테이션을 사용한다.

IoC와 DI의 차이
그리고 DI라는 말은 마틴파울러와 그 주변사람들이 모여 IoC에 범용적인 의미를 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다고 합니다.
그냥 제어의 역전이라 하면 그 차원에서 어느 범위에서 의존성 역전일까요? 단순 객체간의 디자인패턴으로 활용하는것도 제어 역전이고 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서도 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다고 합니다
DI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.
Spring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠.

IoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다.
디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다. 범용적인 표현이죠 하지만 DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미인것이죠.

스프링 빈 등록방식

1. 컴포넌트 스캔과 자동 의존관계 설정 :
스프링이 등록 될 때 @Component 처리된 객체들을 스프링 빈으로 자동 등록시킨다.
@ComponentScan이란, @Controller, @Service, @Repository, @Component, @Configuration 어노테이션 붙은 클래스 빈들을 찾아서 context에  스프링 빈으로 자동 등록한다.
@ComponentScan 어노테이션을 직접 사용하지 않아도 됨. 왜냐하면 @SpringBootApplication 어노테이션 덕분이다.
@ComponentScan은 component scan의 시작 지점을 설정하는 basePackages(), basePackageClasses() 두 가지 속성이 있다.
basePackages()는 scan을 시작할 패키지를 문자열로 지정하고, basePackageClasses()는 스캔을 시작할 클래스 타입을 지정합니다.
@SpringBootApplication은 이 둘을 내장하기 때문에 직접적으로 @ComponentScan 어노테이션을 사용하지 않아도 됨.
@Controller 된 컨트롤러가 스프링 빈으로 자동 등록된 이유도 @ComponentScan 덕분이다.

스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다(유일하게 하나만 등록해서 공유한다)
따라서 같은 스프링 빈이면 모두 같은 인스턴스이다. 설정으로 아니게 설정 가능하지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다.
소프트웨어 디자인 패턴에서 싱글턴 패턴을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.

사용 이유 : 메모리 낭비 줄이기 위해서 사용.

사용 방법:
1. static 객체를 통해서 해당 객체를 1개만 생성할 수 있도록 지정한다.
2. static 메소드를 통해서 외부에서 생성할 수 있도록 제한한다.
3. new 연산자를 통해서 객체를 만드는 것을 private 생성자를 통해서 제한한다.

단점 :
1. 싱글톤 패턴을 사용하는 다른 객체들간의 결합도(의존성)이 높아지기 때문에 객체 지향 설계 원칙에 위배된다.즉, 클라이언트가 구체 클래스에 의존한다.
2. 내부 설계를 변경하거나 초기화하기가 어렵다.
3. private 생성자를 사용하기 때문에 자식 클래스를 만들기 어렵다.

결론적으로 유연하지 않다라는 큰 단점이 존재한다.

스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
그래서 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.


https://velog.io/@jaeeunxo1/spring-singleton

@Autowired로 객체 연결시켜준다.

순서가 있다
url을 보내면 스프링 컨테이너에서 먼저 관련 컨트롤러를 찾고 없으면 .html 파일을 찾는다.
따라서, .html파일이 존재하더라도 관련 컨트롤러가 있으면 컨트롤러를 우선한다.

@GetMapping : 조회할 때 주로 사용
@PostMapping : 데이터를 form에 넣어 전달할 때 사용

Get/Post, form tag 알아보기!

html 내부에 '${}'는 모델 안의 값을 꺼내오는 역할을 한다.

스프링 DB 접근 기술
jdbc : 데이터베이스와 어플리케이션 서버를 연결하는 기술

스프링을 사용하는 이유 : 
개방-폐쇠 원칙(OCP, Open-Closed Principle)
확장에는 열려있고, 수정, 변경에는 닫혀있다.
객체지향적인 설계가 좋은 이유는 다형성(interface와 class 관계)을 이용한다.
스프링은 이러한 점을 쉽게 이용할 수 있도록 스프링 컨테이너가 지원해준다(DI - Dependency-Injection)

통합테스트보다 단위테스트가 좋을 확률이 높다.

