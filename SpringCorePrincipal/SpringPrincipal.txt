스프링을 만든 이유
자바 언어 기반 프레임워크 (객체 지향 언어)
객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
즉, 좋은 객체 지향 애플리케이션을 개발할 수 있게 도외주는 프레임워크이다.

객체 지향 특징
추상화
캡슐화
상속
다형성

객체 지향 프로그램밍이란?
유연하고 변경이 용이하다. 즉, 레고 블럭 조립하듯이, 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법이다.
다형성!

예제1) 자동차 종류가 바뀐다 하더라도 운전자 역할을 가진 객체는 운전 가능하다.
운전자(클라이언트)는 자동차 내구 구현에 대해서는 알 필요 없다.
자동차 역할만 구현한다면, 새로운 기능을 구현하는 자동차가 나와도 운전자(클라이언트)에 영향을 주지 않는다.

예제2) 로미오 역할, 줄리엣 역할에 배역이 누가 맡든 로미오와 줄리엣의 역할만 소화해낸다면 문제 없음.
즉, 배우는 대체 가능하다. 또, 줄리엣의 구현이 바뀐다 하더라도 로미오에 영향을 주지 않는다.

위의 예제들을 통하여 유연하고 변경이 용이하다는 의미를 곱씹을 수 있다.

클라이언트는 대상의 역할(인터페이스)만 알면 된다. 내부구조를 알 필요 없다.
설령, 구현대상의 내부구조가 변경되어도 영향을 받지 않는다. 구현 대상 자체를 변경하더라도 영향을 받지 않는다.

다형성의 본질
클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
확장 가능한 설계이다.

한계
역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.'

SOLID 원칙
로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
SRP : 단일 책임 원칙(single responsibility principle)
한 클래스의 하나의 책임만 가져야 한다. 
하나의 책임이라는 것은 모호(클수도, 작을수도 또는 문맥과 상황에 따라 다르다)
중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
예) UI 변경, 객체의 생성과 사용을 분리

OCP : 개방 - 폐쇠 원칙(Open/Closed Principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야한다.
다형성을 활용!
인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현 (변경 x)
구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자(스프링 컨테이너)가 필요!!

LSP : 리스코프 치환 원칙(Liskov Subsitution Principle)
프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
단순히 컴파일에 성공하는 것을 넘어서는 이야기

예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함.
엑셀 구현을 -10으로 하여 뒤로 가게 하면 컴파일 단계에서는 아무런 문제가 없지만, LSP 위반이라는 의미이다.

ISP : 인터페이스 분리 원칙(Interface Segregation Principle)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.
인터페이스가 명확해지고, 대체 가능성이 높아진다.

DIP : 의존관계 역전 원칙(Dependency Inversion Principle)
구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
역할(Role)에 의존하게 해야 한다는 것과 같다.
의존한다는 의미는 쉽게 말하면, 코드에 대해서 안다와 같은 의미이다.

다형성 만으로는 OCP, DIP를 지킬 수 없다. 자바의 한계!!

<단축키>
오류난 곳으로 이동 : F2
클래스 찾기 : shift 두번

프레임워크 vs 라이브러리
프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크이다. (JUnit) 즉, IoC가 이루어져있다.
예를 들어 @BeforeEach 와 같은 어노테이션을 사용하면, 알아서 각 @Test가 실행되기 전에 @BeforeEach 가 실행된다.
반면, 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리이다.

프레임워크와 라이브러리의 차이점은 "제어 흐름"의 권한이 어디에 있는가입니다.
라이브러리를 사용할 때 사용자는 애플리케이션 코드의 흐름을 직접 제어해야 합니다.
개발 시 필요한 기능이 있을 경우 능동적으로 라이브러리를 호출하여 사용하거나 기존에 구성된 함수나 코드를 가져다 써야 합니다. 
반면 프레임워크는 애플리케이션의 코드가 프레임워크에 의해 사용됩니다.
애플리케이션 코드는 프레임워크가 짜 놓은 틀에서 수동적으로 동작하기 때문에 제어의 흐름은 프레임워크가 가지고 있고 사용자가 그 안에 필요한 코드를 작성하게 됩니다.

정적인 클래스 의존관계
import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있ㄷ.
그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 주입 될지 알 수 없다.

동적인 객체 인스턴스 의존관계
애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다.
애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트 서버의 실제 의존과계가 연결 되는 것을 의존관계 주입(DI)이라고 한다.
의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고(==코드를 손대지 않고), 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

IoC 컨테이너, DI 컨테이너
AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 혹은 DI 컨테이너라고 한다.
의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다. 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

주의! 빈 이름은 항상 다른 이름을 부여해야한다. 이유는 다른 빈이 무시되거나, 기존 빈을 덮어버리는 등 설정에 따라 오류가 발생한다.
스프링 빈의 key는 메소드 이름이고, 값은 반환객체이다.

스프링은 빈을 생성하고(준비), 의존관계를 주입하는 단계(완료)가 나누어져있다.

스프링 빈 조회 :
부모 타입 조회 시, 자식 타입도 함께 조회한다. 그래서 모든 자바 객체의 최고 부모인 'Object' 타입으로 조회하면 모든 스프링 빈을 조회한다.

BeanDefinition
스프링이 다양한 설정 형식을 지원하게 될 수 있는 이유의 중심에는 BeanDefinition이라는 추상화가 존재하기 때문이다.
xml 혹은 자바 코드를 읽어서 BeanDefinition을 만들면 된다.
BeanDefinition을 빈 설정 메타정보라 한다. @Bean, <bean>당 각각 하나씩 메타 정보가 생성된다.
스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

메타데이터란 어플리케이션이 처리해야 할 데이터가 아니라, 컴파일 타임과 런타임에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보입니다.

스프링 컨테이너 -----> BeanDefinition

BeanFactory를 상속하는 ApplicationContext를 상속하는 AnnotatedConfigApplicationContext는 AnnotatedBeanDefinitionReader을 이용하여 AppConfig.class를 읽고 BeanDefinition을 생성한다.

스프링에 빈을 등록하는 방식
1. 직접 등록(appConfig.xml)
2. FactoryMethod를 사용(AppConfig.java) 어노테이션을 사용하면 factoryBean에서 factoryMethod를 찾아 등록하는 방식이다.

getBeanDefinition을 사용하여 출력값을 보면, xml방식은 클래스가 명확하게 명시되는 반면, factoryMethod방식은 없다.
하지만, xml방식은 factoryBeanName/MethodName이 null로 표시되지만, factorymethod방식은 표시된다.

싱글톤 컨테이너
객체가 JVM 안에 딱 하나만 있어야하는 패턴

웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
고객이 3번 요청하면 객체가 3번 생성된다. -> 효율적이지 않다.

해결책!
해당 객체가 한 번만 생성하고 공유하도록 한다 -> 싱글톤 패턴

싱글톤 패턴
클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다.
그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.

왜 쓰나요?
먼저, 객체를 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 한번의 new를 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.
또한 싱글톤으로 구현한 인스턴스는 '전역'이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.

스프링 컨테이너는 기본적으로 객체를 싱글톤으로 만들어서 관리해준다.(싱글톤 레지스트리)
이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
DIP,OCP,테스트,private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.

주의점!
여러 클라이언트가 하나의 같은 객체를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
무상태(stateless)로 설계해야한다.
특정 클라이언트에 의존적인 필드가 있으면 안된다.
특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
가급적 읽기만 가능해야한다.
필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal등을 사용해야한다.
스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.

stateful vs stateless
https://irostub.github.io/web/stateful-stateless/

@Configuration : 바이트 코드를 조작해서 싱글톤 방식을 유지하게끔 한다.
ex) AppConfig에 @Configuration을 붙이면, 스프링 컨테이너에는 AppConfig를 상속하는 AppConfig@CGLIB를 스프링 컨테이너에 등록한다.
그리고 내부 메소드에는 만약 스프링 컨테이너에 반환객체가 등록이 안되어있다면 기존 코드를 이용해 등록하고, 이미 등록이 되어있다면 그 등록된 객체를 꺼내쓴다.

만일 @Configuration없이 @Bean만 쓰면 어떻게 될까?
스프링 빈으로 등록이되지만, 싱글톤이 이루어지지 않는다.

컴포넌트 스캔
직접 빈을 등록할 수도 있지만(xml, @Bean), 빈의 개수가 늘어나면 등록하기도 힘들고 설정정보도 커질뿐더러 누락 가능성도 발생한다.
이를 해결하기 위해서 스프링은 컴포넌트 스캔이라는 기능을 제공한다.
또 의존관계도 자동으로 주입하는 @Autowired 기능도 제공한다.
@ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.
이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.

컴포넌트 스캔을 사용하면 AppConfig와 같이 설정정보를 안 쓰기 때문에 의존관계 주입을 해 줄 수 있는 방법이 없다.
따라서 이를 위해 @Autowired가 나타나서 스프링 빈을 뒤져서 타입이 맞는 빈을 가져온다.  

생성자에 @Autowired를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
getBean(MemberRepository.class)와 동일하다고 이해하면 된다.

어노테이션에는 상속관계 없다. 따라서 어노테이션이 특정 어노테이션을 들고 있는 것(@SpringBootApplication이 @Component 들고 있는 경우 etc)을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다.

includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

FilterType 옵션(@Filter)
ANNOTATION : 기본값(생략가능), 어노테이션을 인식해서 동작한다.
ex) org.example.SomeAnnotation
ASSIGN_TYPE : 지정한 타입과 자식 타입을 인식해서 동작한다.
ex) org.example.SomeClass
ASPECTJ : AspectJ 패턴 사용
ex) org.example..*Service+
REGEX : 정규 표현식
ex) org/.example/.Default.*
CUSTOM : TypeFilter 이라는 인터페이스를 구현해서 처리
ex) org.example.MyTypeFilter

만약 BeanA도 빼고 싶다면, excludeFilter의 Filter 타입에 ASSIGNABLE_TYPE, classes = BeanA.class (직접 클래스 지정) 하면 된다.

중복 등록과 충돌
컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까
자동 빈 등록 vs 자동 빈 등록
스프링이 오류 발생 시킴.(ConflictingBeanDefinitionException 발생)

수동 빈 등록 vs 자동 빈 등록
이 경우 수동 등록 빈이 우선권을 가진다.
수동 빈이 자동 빈을 오버라이딩 해버린다. (Overriding bean definition for bean)
의도하지 않은 이런 방식은 어려운 버그를 발생시켜버린다.
그래서 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.

의존관계 주입 방법
1.생성자 주입
생성자 호출 시점에 딱 1번만 호출된다는 것이 보장된다.
불변(setter 메서드 만들지 말자!),필수(final 키워드 적용된 값 무조건 초기화) 의존관계에 사용
생성자가 딱 1개만 있으면 @Autowired 생략가능! 물론 스프링 빈에만 적용된다.
원래는 빈 등록 단계와 의존관계 주입이 따로 이루어지지만 생성자 주입은 예외로 같이 일어난다.
이유는 예를 들어 OrderServiceImpl을 스프링 빈에 등록 시, new OrderServiceImpl()을 하게 되는데 이 때 생성자가 불리게 된다.
생성자 호출 시점에 딱 1번만 호출합니다.(불변)
주입 데이터를 누락했을 때 컴파일 시점에 컴파일 오류가 발생합니다.
final 키워드를 사용할 수 있습니다.(불변)
원하는 구현체를 주입할 수 있으며, 순수 자바 코드로 테스트를 할 수 있습니다.(프레임워크에 의존하지않음)

2.수정자 주입(setter 주입)
setter 메서드에 @Autowired를 붙여 빈과 연결시겨 의존관계 주입시킨다.
생성자 주입과 함께 있으면 생성자 주입 다음으로 이루어진다. 
선택(인자가 빈 등록이 되어있지 않는다 하더라도 사용가능, @Autowired(required = false)) 필수값이 아니므로 있어도 되고 없어도 된다. 또는 변경 가능성이 있는 의존관계에 사용
수정자 주입을 사용하게 되면 불필요하게 객체의 수정 가능성을 열어두게 되는데, 이는 OOP(객체 지향 프로그래밍)의 5가지 개발 원칙 중에 OCP(Open-Closed Principal, 개방-폐쇄 원칙)를 위반하게 됩니다.
자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

자바빈 프로퍼티 : 필드의 값을 직접 변경하지 않고, setter/getter 메서드를 이용하여 값을 읽거나 수정하는 규칙을 말한다.

3. 필드 주입
필드에 값을 바로 주입한다.
하지만 외부에서 변경이 불가능하기에 테스트 하기 매우 힘들다.
필드 인스턴스 변수 값을 더미 값으로 변경하려고 해도 불가능하다.
DI 프레임워크가 없으면 아무것도 할 수 없다.
되도록 사용하지 않도록 하자.
사용하는 경우
1. 실제 어플리케이션의 코드와 관련 없는 경우(test)
2. 스프링 설정을 목적으로 하는 @Configuration같은 곳에서만 특별한 용도로 사용

4. 일반 메서드 주입
일반 메서드를 통해서 주입 받을 수 있다.
한번에 여러 필드를 주입 받을 수 있다.

의존성 주입 방법이 동시에 여러개 있다면?
"생성자 -> 필드 -> 메서드" 순이다.
1. 생성자를 통해 생성
2. @Autowired 어노테이션이 달린 필드 주입
3. @Autowired 어노테이션이 달린 메서드 호출

@Autowired 옵션 처리
주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
@Autowired required 옵션의 기본값이 true로 되어있어서 자동 주입 대상이 없으면 오류가 발생한다.
자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
@Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다.
Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

생성자 주입을 선택하라
이유 :
1. 불변 : 대부분의 의존관계는 종료시점까지 변경할 일이 없다. 오히려 대부분은 변하면 안된다.(불변해야한다)
수정자 주입을 사용하면 set 메서드를 public으로 열어둬야하는데 이로 인하여 실수로 변경될 수 있고 좋으 ㄴ설계방법이 아니다.
생성자 주입은 객체 생성 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계 가능하다.

2. 누락 : 프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우
생성자 주입을 사용하면 주입 데이터를 누락 했을 때 "컴파일 오류"가 발생한다.
그리고 IDE에서 바로 어떤 값을 필수로 주입 하는지 알 수 있다.

fianl 키워드
생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.
객체 안의 변수라면 생성자, static 블럭을 통한 초기화까지는 허용
수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 호출 이후에 호출되므로, 필드에 fianl 키워드를 사용할 수 없다.
오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.

컴파일 오류가 세상에서 가장 빠르고 좋은 오류다!!

생성자 주입 방식을 선택하는 이유는 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이다.
기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
항상 생성자 주입을 선택하라! 가끔 옵션이 필요하면 수정자 주입을 선택하라.

롬복과 최신 트랜드
생성자도 만들고 주입 받는 값을 대입하는 코드도 만든 것
@Getter/@Setter 넣어주면 직접 코드 작성을 하지 않고서도 setName/getName 메서드 이용가능
@RequiredArgsConstructor : final이 붙은 변수의 생성자를 생성해준다. 즉 생성자를 직접 짜 줄 필요가 없다.

스프링 빈 충돌
fixedDiscountPolicy를 스프링 빈으로 등록 했을 때 스프링 컨테이너는 생성자에서 인자의 형을 보고 주입을 하려고 하기 때문에 rateDiscountPolicy와 충돌이 발생한다.

@Autowired 필드 명 매칭 : 타입 매칭을 시도하고, 이 때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
예를 들어 생성자 인자 이름을 discountPolicy에서 rateDiscountPolicy로 바꾸면 인자명에 매칭되는 인스턴스를 가져온다.
정리 :
1. 타입 매칭
2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭

@Qualifier : 추가구분자
구분하고자 하는 클래스나 필드 등  @Qualifier("mainDiscountPolicy") 한 후, 주입되는 필드나 파라미터, 수정자 앞 등에 다음과 같이 붙이면 스프링 컨테이너가 매칭되는 빈을 끌어와준다.
@Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy
만약 mainDiscountPolicy을 못찾으면 mainDiscountPolicy라는 이름의 스프링 빈을 추가로 찾는다. 하지만 @Qualifier는 @Qulifier를 찾는 용도로만 사용하는게 좋다.
정리 :
1. @Qulifier끼리 매칭 (추천)
2. 빈 이름 매칭
3. NoSuchBeanDefinitionException 예외 발생

@Primary 사용 (자주 사용됨) : 우선순위 정하는 방법. @Autowired 시 여러 빈 매칭되면 @Primary 가 우선권을 가진다.
자주 사용되는 경우 : 메인데이터(사용률 95%), 보조데이터(어쩌다 한 번)이 있다 가정. 메인데이터 소스에는 @Primary를 걸어준다. 보조데이터에는 @Qulifier를 걸어주자. 

@Qulifier 단점은 매번 붙여줘야한다. 반면, @Primary는 @Qulifier와 같이 매번 붙일 필요 없다.

우선순위!!!
@Primary는 기본값 처럼 동작, @Qulifier는 매우 상세하게 동작한다.
스프링은 자동보다는 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선 순위가 높다. 따라서 같이 있는 경우 @Qulifier가 우선권이 높다.

단축키>
구현체 바로 진입 : ctrl + alt + b

애노테이션 직접 만들기 : 
@Qulifier("mainDiscountPolicy")를 만들게 되면 문제점은, 문자를 적으면 컴파일시 타입 체크가 안된다.
즉, mainn... 이런식으로 typo가 생겨도 컴파일 단계에서 체크불가하다.
따라서 어노테이션을 만들어서 문제 해결 가능하다.

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
}

어노테이션에는 상속이라는 개념이 없다. 여러 어노테이션을 모아서 사용하는 기능은 스프링이 지원하는 기능이다.	

List, Map
의도적으로 정말 해당 타입의 스프링 빈이 다 필요한 경우도 있다.
예를 들어, 할인 관련 서비스 제공하는데 클라이언트가 할인의 종류를 선택가능하다고 하자.
스프링을 사용하면, 전략 패턴을 매우 간단히 구현 가능하다.
AllBeanTest 참고!

자동, 수동의 올바른 실무 운영 기준
편리한 자동 기능을 기본으로 사용하자
최근 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고, 스프링 부트의 다양한 스프링 빈들도 조건이 맞으면 자동으로 등록하도록 설계했다.
애플리케이션 구성부분과 구현부분을 명확히 나누는 것이 이상적이지만, 개발자 입장에서는 아니다.
결정적으로 자동 빈 등록을 사용해도 OCP,DIP를 지킬 수 있다. 스프링 컨테이너가 어노테이션 보고 자동으로 스프링 컨테이너에 빈으로 등록하고 주입한다.

수동 빈 등록은 언제 사용하면 좋을까?
어플리케이션은 크게 아래와 같이 나누어진다.
업무 로직 : 웹 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
기술 지원 : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부기술이나 공통 기술들이다.

업무 로직은 숫자도 많고 유사한 패턴 존재 -> 자동 기능 적극 사용. 문제 발생해도 명확하게 파악가능
1. 기술 지원 로직은 업무 로직에 비해 수가 적다. 하지만 광범위하게 영향을 미친다. 또한 적용이 잘 되고 있는지 아닌지 조차 파악하기 힘들다.
그래서 가급적 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.
예를 들어 @Configuration 이 붙은 설정 정보(전반위에 영향미침)들은 root에 꺼내두는것이 좋다.

정리 : 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록! 설정 정보에 바로 나타나게끔 함.

2. 비즈니스 로직 중에서 다형성을 적극 활용할 때
예를 들어 DiscountService 클래스를 보면 DiscountPolicy에 어떤 빈들이 주입될 지 한눈에 파악하기 힘들다.
하지만 만약 DiscountConfig 설정 코드(수동 빈 등록)를 짜면 한눈에 파악 가능하다.
이런 경우 수동 빈으로 등록하거나 또한 자동으로 하면 특정 패키지에 같이 묶어두는게 좋다.

참고로 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외이다.

정리
편리한 자동 기능을 기본 사용하자
직접 등록하는 기술 지원 객체는 수동 등록
다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자.

빈 생명주기 콜백
데이터베이스 커넥션 풀(애플리케이션이랑 db를 미리 연결해둔다), 네트워크 소켓처럼 애플리케이션 시작 시점에 미리 연결해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 직업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.

스프링 빈은 객체 생성 -> 의존관계 주입 라이프사이클을 가진다.

초기화라는 것은 객체를 생성하는 작업을 의미하지 않는다. 외부랑 연결해서 처음 일을 시작하는 과정을 의미한다.

개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까?
스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.
스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.

스프링 빈의 이벤트 라이프사이클
스프링 컨테이너 생성 -> 스프링 빈 생성(constructor 주입) -> 의존관계 주입(setter/field 주입) -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
소멸전 콜백 : 빈이 소멸되기 직전에 호출

생성자에 다 주입하면 되지 않나요?
객체의 생성과 초기화를 분리하자! 단일체계원칙에 기반하여, 객체생성단계에는 객체 생성하는것에만 집중!
초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.
유지보수 관점에서 분리하는것이 좋다. 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 하는것이 더 나을 수 있다.
분리하면 동작 지연도 가능하다.

콜백 받는 방법
1. 인터페이스 활용(InitializingBean, DisposableBean) : 초창기때 나옴, 잘 사용되지 않는다.
각각 afterPropertiesSet(), destroy() 메서드 구현하면 됨.
전자는 초기화 단계, 후자는 소멸단계에 호출됨.
단점 : 
	1. 스프링 전용 인터페이스. 따라서 해당 코드가 스프링 전용 인터페이스에 의존해야한다.
	2. 초기화, 소멸 메서드의 이름 변경 불가
	3. 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다. 초기화와 종료를 해줘야하는데 수정불가

외부 라이브러리 : 오픈소스라 이해! 이 경우 우리가 소스코드를 포함하는 것이 아닌 이미 컴파일된 class 파일이 모여있는 jar 파일을 포함하게 된다.
따라서 소스코드 수정 불가

2. 소멸 메서드 사용 : 설정 정보에 @Bean(initMethod = "init", destoryMethod = "close") 처럼 초기화, 소멸 메서드를 지정할 수 있다.
장점 :
	1. 메서드 이름 자유롭게 줄 수 있다.
	2. 스프링 빈이 스프링 코드에 의존하지 않는다. (InitializingBean, DisposableBean은 springframework 의존)
	3. 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다. @Bean(initMethod = "init", destroyMethod = "close")

@Bean의 destoryMethod 속성 : default는 (inferred)이다.
라이브러리는 대부분 close, shutdown 이라는 이름의 종료 메서드를 사용한다.
이 추론 기능은 close, shutdown 라는 이름의 메서드를 찾아 자동으로 호출해준다.
따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.
추론 기능을 사용하기 싫다면 destroyMethod = "" 처럼 빈 공백을 지정하면 된다.

3. 애노테이션 @PostConstruct, @PreDestory (이 방법을 사용하자!)
@PreDestroy runs only once, just before Spring removes our bean from the application context.
스프링이 스프링 컨테이너에서 빈을 제거하기 전에 알려주는 콜백이다.

장점 :
	1. 애노테이션 하나만 붙이면 되므로 매우 편리하다.
	2. 패키지를 보면 javax.~~ 이다. 스프링에 종속적인 기술이 아니라 자바 표준이기에 스프링이 아닌 다른 컨테이너에도 동작한다.
	3. 컴포넌트 스캔과 잘 어울린다. @Component를 붙여도 애노테이션이기에 잘 작동한다.

단점 :
	1. 외부 라이브러리에는 적용하지 못한다는 것이다(코드를 고쳐야 하기 때문 - 애노테이션 붙여야함). 외부 라이브러리를 초기화, 종료 해야하면 @Bean의 기능을 사용하자.

정리
@PostConstruct, @PreDestory 사용하자
코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야하면 @Bean의 initMethod, destory 옵션 사용하자

빈 스코프
스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문에 위의 라이프사이클을 따른다.

스프링은 다양한 스코프 지원한다
싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
프로토타입 : 스프링 컨테이너는 프로토타입의 빈의 생성과 의존관계 주입까지만 관여
웹 관련 스코프
request : 웹 요청이 들어오고 나갈때까지 유지
session : 웹 세션이 생성되고 종료될 때 까지 유지
application : 웹의 서블릿 컨텍스와 같은 범위로 유지

프로토타입 스코프 : 싱글톤 스코프와 다르게 항상 새로운 인스턴스를 생성해서 반환한다. 반환 후 버린다.

정리
스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리!
프로토타입 빈을 관리할 책임은 클라이언트에 있다. 그래서 @PreDestory같은 종료 메서드가 호출되지 않는다.
종료 메서드(콜백)은 스프링이 스프링 컨테이너에서 빈을 제거하기 전에 호출하는데 프로토타입 스코프 빈은 이미 클라이언트에 전달하였기 때문에 더이상 스프링 컨테이너에 없어서 @PreDestroy 종료메서드를 호출할 수 없다.


정리
싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 되지만, 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.
프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고 더는 관리하지 않기에 컨테이너가 종료될 때 @PreDestory같은 종료 메서드가 전혀 실행되지 안흔ㄴ다.
따라서 프로토타입 빈은 프로토타입 빈을 조회환 클라이언트가 관리해야한다. 종료 메서드에 대한 호출도 클라이언트가 직접 관리 해야한다.


싱글톤 빈과 프로토타입 빈을 같이 사용시 생기는 문제점 해결하기
싱글톤 빈이 프로토타입 빈 사용할 때마다 새로 요청하게끔 하기.

@Autowired
ApplicationContext ac; 

위와 같이 Dependency Lookup(DL) 의존관계 조회(탐색) 방법을 통하여 해결할 수는 있지만, 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.

싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을 생성할 수 있을까? 즉, 어떻게 하면 싱글톤 빈이 스프링 컨테이너에 프로토타입 빈을 요청하여 싱글톤 빈에 프로토타입 빈이 종속되지않도록 할까?

static class ClientBean {
 private final PrototypeBean prototypeBean;
 //Autowired를 통하여 DI를 해서 이용하기에 프로토타입빈이 싱글톤 빈에 의존한다.
 @Autowired
 public ClientBean(PrototypeBean prototypeBean) {
 this.prototypeBean = prototypeBean;
 }
 public int logic() {
 prototypeBean.addCount();
 int count = prototypeBean.getCount();
 return count;
 }
 }

위의 코드를 실행하면 count가 점점 늘어나는 것을 확인할 수 있다.

따라서 아래의 코드를 통하여 logic 메서드를 실행할 때마다 logic 메서드 안의 getBean을 통하여 컨테이너로부터 PrototypeBean을 능동적으로 찾아낸다.(Dependency Lookup)
즉, logic을 실행할 때마다 새로운 프로토타입 빈이 호출된다.
하지만 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.

static class ClientBean {
 @Autowired
 private ApplicationContext ac;
 public int logic() {
 PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class);
 prototypeBean.addCount();
 int count = prototypeBean.getCount();
 return count;
 }
 }

Provider 사용하자

지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다. 자바 표준 사용
스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
ObjectProvider 는 지금 딱 필요한 DL 정도의 기능만 제공한다

1. ObjectProvider 기능 중 하나인 getObject() 활용하자!
스프링 컨테이너 기능 부분 활용. 
ObjectProvider의 getObject()를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
빈으로 자동등록 시켜준다.
별도의 라이브러리 필요없다.
지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider

@Autowired
private ObjectProvider<PrototypeBean> prototypeBeanProvider;
public int logic() {
 PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
 prototypeBean.addCount();
 int count = prototypeBean.getCount();
 return count;
}


2. 자바 표준을 이용하는 Provider의 get() 활용하자!
Provider의 get()를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
별도의 라이브러리 필요.
자바 표준이기에 스프링이 아닌 다른 컨테이너에서도 사용가능하다.

정리
프로토타입은 언제 사용할까? 실무에서는 거의 사용하지 않는다.
ObjectProvider, JSR330 Provider 등은 프로토타입 뿐만 아니라 DL이 필요한 경우 언제든지 사용가능하다.
순환 참조 방지(공부하자!)

JSR330 Provider은 스프링 외 다른 컨테이너에서 사용할 때 사용하자.
자바 표준과 스프링이 제공하는 기능이 겹칠때가 생기면 스프링이 제공하는 기능을 사용하자.

웹 스코프
웹 환경에서만 작동
프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.

종류
request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성 및 관리된다.
session : HTTP Session과 동일한 생명주기를 가지는 스코프
application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프

스코프와 프록시
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)를 하면 MyLogger 클래스 짭퉁을 만들어서 주입시켜준다.